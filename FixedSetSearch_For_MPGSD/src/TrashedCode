Contains all the code which was removed due to improvement or is just not needed anymore

//	public static LinkedList<LinkedList<Vertex>> GreedySolve(MPGSDGraph g) {
//		LinkedList<LinkedList<Vertex>> allSubgraphs = new LinkedList<>();
//		
//		
//		for(int i = 0; i <=  g.getListOfSupplyVertexes().size() - 1; i++) {
//			
//			SupplyVertex SupV = g.getHighestSupplyVertex();
//			LinkedList<Vertex> subGraph = new LinkedList<Vertex>();
//			allSubgraphs.add(subGraph);
//			subGraph.add(SupV);
//			Vertex currentV = SupV;
//			
//			while(true) {
//				//TODO When demandVertex not null
//				Vertex[] demandPair = getHighestListAdjVertex(subGraph);
//				DemandVertex selctedAdjDemV = (DemandVertex) demandPair[0];
//				if(selctedAdjDemV == null) {
//					break;
//				}
//				currentV = demandPair[1];
//				currentV.addAdjVertex(selctedAdjDemV);
//				selctedAdjDemV.setPredecessor(currentV);
//				subGraph.add(selctedAdjDemV);
//				SupV.useSupply(selctedAdjDemV.getDemand());
//				selctedAdjDemV.setDemandAsCovered();
//			}
//			
//		}
//		
//		return allSubgraphs;
//	}

public static Vertex[] getHighestListAdjVertex(SubGraph vListSubgraph) {
		//because first element in subgraph is always the supply Vertex
		
		int remainingSupply = vListSubgraph.getSubgraphsSupplyVertex().getRemainingSupply();
		//TODO null fix?
		DemandVertex bestFittingDemandVertex = null;
		Vertex predecessor = null;
		int maxDem = 0;
		LinkedList<Vertex> vList = vListSubgraph.getVertexList(); 
		
		for (int i = 0; i <= vList.size() - 1; i++ ) {
			Vertex k = vList.get(i);
			//getHighestFittingAdjVertex is swappable with function of choise
			DemandVertex currentAdjDemV = (DemandVertex) k.getHighestFittingAdjVertex(remainingSupply /*, vList*/);
			if(currentAdjDemV != null) {
				/*
				 * TODO currently only takes the one with the most demand of the given
				 */
				if(maxDem < currentAdjDemV.getDemand()) {
					maxDem = currentAdjDemV.getDemand();
					bestFittingDemandVertex = currentAdjDemV;
					predecessor = k;
				}
			}
			
			
		}
		return new Vertex[] {bestFittingDemandVertex, predecessor};
	}
	
	
	/*
	 * returns the highest fitting Vertex, that is not already in a subgraph (demand covered),
	 * highest fitting, means Vertex with the most Adj Vertexes, which demand can be fullfilled
	 */
	public Vertex getVertexWMostAdjV(int remainingSupply) {
		int currentMaxAdjV = 0;
		Vertex currentMaxAdjVertex = null;
		
		for (int i = 0; i <= AdjVertexList.size() - 1; i++) {
			Vertex k = AdjVertexList.get(i);
			
			if(!k.isSupplyVertex && ((DemandVertex) k).getDemandIsCovered() == false && remainingSupply >= ((DemandVertex) k).getDemand()) {
				if(k.AdjVertexList.size() > currentMaxAdjV) {
					currentMaxAdjV = k.AdjVertexList.size();
					currentMaxAdjVertex = k;
				}
			}
		}
		return currentMaxAdjVertex;
	}
	
	
	/*
	 * returns the highest fitting Vertex, that is not already in a subgraph (demand covered),
	 * highest fitting, means Vertex with the most supply, which can be fullfilled
	 */
	public Vertex getHighestFittingAdjVertex(int remainingSupply /*, LinkedList<Vertex> vList*/) {
		int currentMaxDemand = 0;
		Vertex currentMaxAdjDemandVertex = null;
		
		for (int i = 0; i <= AdjVertexList.size() - 1; i++) {
			Vertex k = AdjVertexList.get(i);
			
			
			if (k instanceof DemandVertex) {
				int currentDemand = ((DemandVertex) k).getDemand();
				if(currentMaxDemand < currentDemand && currentDemand <= remainingSupply && ((DemandVertex) k).getDemandIsCovered() == false /*&& !vList.contains(k)*/) {
					currentMaxDemand = currentDemand;
					currentMaxAdjDemandVertex = k;
				}
				
			}
		}
		return currentMaxAdjDemandVertex;	
	}
	
	
	
		/*
	 * returns the highest fitting Vertex, that is not already in a subgraph (demand covered),
	 * highest fitting, means Vertex with the best Ratio of 1 / (demand / adjacent Vertexes that are not covered)
	 * and that the demand can be fullfilled
	 */
	public Vertex getVertexUsingDemVertexRatio(int remainingSupply) {
		double currentBestRatio = 0;
		Vertex currentBestRatioVertex = null;
		
		for (int i = 0; i <= AdjVertexList.size() - 1; i++) {
			Vertex k = AdjVertexList.get(i);
			
			if(!k.isSupplyVertex && ((DemandVertex) k).getDemandIsCovered() == false && remainingSupply >= ((DemandVertex) k).getDemand()) {
				int numberOfAdjVDemNotCovered = 0;
				/*
				 * Determines how many Adj vertexes arent supplyed yet
				 */
				for(int j = 0; j <= k.AdjVertexList.size() - 1 ; j++) {
					Vertex kj = k.AdjVertexList.get(j);
					if(!kj.getIsSupplyVertex() && !((DemandVertex) kj).getDemandIsCovered()) {
						numberOfAdjVDemNotCovered += 1;
					}
				}
				int demToCov = ((DemandVertex) k).getDemand();
				double x = demToCov / (numberOfAdjVDemNotCovered + 1);
				double currentRatio = 1 / x;
				System.out.println(x);
				if(currentRatio > currentBestRatio) {
					currentBestRatio = currentRatio;
					currentBestRatioVertex = k;
				}
			}
		}
		return currentBestRatioVertex;
	}
	
	
		public Vertex getRandomAdjVertex(int remainingSupply) {
		
		Vertex ranAdjVer = null;
		LinkedList<Vertex> possibleAdjDemandVertexes = getListOfAdjNotCoveredFittingVertexes(remainingSupply);
		int sizeList = possibleAdjDemandVertexes.size();
		if(sizeList > 0) {
			Random randomNumber = new Random();
			int ranAdj = randomNumber.nextInt(sizeList);
			ranAdjVer = possibleAdjDemandVertexes.get(ranAdj);
		}
		return ranAdjVer;
	}
	
	
	/*
	 * returns the highest fitting Vertex using either
	 * getHighestFittingAdjVertex (Adj Vertex with highest demand)
	 * getVertexWMostAdjV (Vertex with most adj Vertexes)
	 * getVertexUsingDemVertexRatio (determines Vertex by combining both criteria)
	 */
	public Vertex getVertexUsingRandomTrait(int remainingSupply) {
		Vertex randomBestVertex = null;
		//Random number between 1 and 3
		Random randomNumber = new Random();
		int ranOneTwoThree = randomNumber.nextInt(3) + 1;
		switch (ranOneTwoThree) {
		case 1:
			randomBestVertex = getHighestFittingAdjVertex(remainingSupply);
			break;
		case 2:
			randomBestVertex = getVertexWMostAdjV(remainingSupply);
			break;
		case 3:
			randomBestVertex = getVertexUsingDemVertexRatio(remainingSupply);
			break;
		default:
			break;
		}
		
		return randomBestVertex;
	}
	
	
	private void createFirstMPGSDGraph() {
		SupplyVertex sup1 = new SupplyVertex(1, 10);
		SupplyVertex sup2 = new SupplyVertex(2, 5);
		SupplyVertex sup3 = new SupplyVertex(3, 7);
		SupplyVertex sup4 = new SupplyVertex(4, 8);
		listOfSupplyVertexes.add(sup1);
		listOfSupplyVertexes.add(sup2);
		listOfSupplyVertexes.add(sup3);
		listOfSupplyVertexes.add(sup4);
		
		DemandVertex dem1 = new DemandVertex(5, 3);
		DemandVertex dem2 = new DemandVertex(6, 4);
		DemandVertex dem3 = new DemandVertex(7, 2);
		DemandVertex dem4 = new DemandVertex(8, 1);
		
		DemandVertex dem5 = new DemandVertex(9, 5);
		
		DemandVertex dem6 = new DemandVertex(10, 4);
		DemandVertex dem7 = new DemandVertex(11, 3);
		DemandVertex dem8 = new DemandVertex(12, 2);
		DemandVertex dem9 = new DemandVertex(13, 1);
		
		DemandVertex dem10 = new DemandVertex(14, 3);
		DemandVertex dem11 = new DemandVertex(15, 1);
		DemandVertex dem12 = new DemandVertex(16, 2);
		DemandVertex dem13 = new DemandVertex(17, 7);
		listOfDemandVertexes.add(dem1);
		listOfDemandVertexes.add(dem2);
		listOfDemandVertexes.add(dem3);
		listOfDemandVertexes.add(dem4);
		listOfDemandVertexes.add(dem5);
		listOfDemandVertexes.add(dem6);
		listOfDemandVertexes.add(dem7);
		listOfDemandVertexes.add(dem8);
		listOfDemandVertexes.add(dem9);
		listOfDemandVertexes.add(dem10);
		listOfDemandVertexes.add(dem11);
		listOfDemandVertexes.add(dem12);
		listOfDemandVertexes.add(dem13);
		
		//Adjacency initialisation
		sup1.addAdjVertex(dem1);
		sup1.addAdjVertex(dem5);
		sup1.addAdjVertex(sup3);
		
		sup2.addAdjVertex(dem5);
		sup2.addAdjVertex(dem10);
		sup2.addAdjVertex(dem6);
		
		sup3.addAdjVertex(dem6);
		sup3.addAdjVertex(dem8);
		
		sup4.addAdjVertex(dem11);
		sup4.addAdjVertex(dem12);
		sup4.addAdjVertex(dem4);
		
		dem1.addAdjVertex(dem2);
		dem2.addAdjVertex(dem3);
		dem2.addAdjVertex(dem5);
		dem3.addAdjVertex(dem4);
		
		dem10.addAdjVertex(dem11);
		dem12.addAdjVertex(dem13);
		dem7.addAdjVertex(dem6);
		dem7.addAdjVertex(dem8);
		dem9.addAdjVertex(dem7);
		dem9.addAdjVertex(dem8);
		
		
	}
	
	IN SUPPLYVERTEX
	
	public void setInSubGraphTrue() {
		isInSubgraph = true;
	}
	
	public boolean getIsInSubGraph() {
		return isInSubgraph;
	}
	
	
	------------------------------------------------------------------------------------------------------------
	//Not Trashed but for PseudoCode
	public static SolvedGraph GreedySolve2(graph, trait) {
		resetGraphVertices(graph);
		SolvedGraph graphOfSubGraphs = new SolvedGraph(graph);
		
		graphOfSubGraphs.updateSupAndDem(graph.getSupAndDem())
		
		
		
			
		while(true) {
			
			selctedSubGraph = graphOfSubGraphs.getSubgraphWithHigestSupply();
			
			if selctedSubGraph is null:
				break;
			
			
			selctedAdjDemV = selctedSubGraph.getVertexToAdd(trait);
			
			if(selctedAdjDemV == null) {
				selctedSubGraph.setComplete();
				
			}else {
				selctedAdjDemV.updateVertex();
				selctedSubGraph.addVertex(selctedAdjDemV);	
				graphOfSubGraphs.updateSupAndDem(selctedAdjDemV.getDemand());
			}
			
		}
		
		return graphOfSubGraphs;
	}
	
	public static List<SubGraph> getFixedSets(MPGSDGraph g, int t, int m, double threshold) throws IOException{
		
		
		
		int amountOfSubGraphs = g.getNumberofSupplyVertexes();
		
		List<SubGraph> fixedSets = new LinkedList<SubGraph>();
		
		SolvedGraph[] arrayOfBestGreedySolutions = new SolvedGraph[m];
		
		//solves the given graph g i times
		for(int i = 0; i <= t; i++) {
			
			//4 being random trait
			SolvedGraph JSONGraphSolution = GreedyMPGSDSolver.GreedySolve2(g, 4);
			
			int covSup = JSONGraphSolution.getTotalCoveredDemand();
			int totalSup = JSONGraphSolution.getTotalGivenSupply();
			double supPercentCovered = (double)covSup / (double)totalSup;

			if(supPercentCovered > threshold) {
				boolean placefound = false;
				for(int j = 0; j <= m - 1; j++) {
				
					if(arrayOfBestGreedySolutions[j] == null) {
						arrayOfBestGreedySolutions[j] = JSONGraphSolution;
						
						placefound = true;
						break;
					}
				}
				//otherwise checks if the current solution outperforms another and replaces it
				for(int j2 = 0; j2 <= m - 1; j2++) {
						if(arrayOfBestGreedySolutions[j2].getTotalCoveredDemand() < JSONGraphSolution.getTotalCoveredDemand()) {
							arrayOfBestGreedySolutions[j2] = JSONGraphSolution;
							
							break;
						}
						
					
				}
			}
		}
		
		if(arrayOfBestGreedySolutions[0] == null) {
			SolvedGraph replacementGraph = new SolvedGraph(g);
			arrayOfBestGreedySolutions[0] = replacementGraph;
		}
		
		LinkedList<LinkedList<SubGraph>> ListForEachSupply = new LinkedList<>();
		
		for(int n = 0; n <= amountOfSubGraphs - 1; n++) {
			LinkedList<SubGraph> subgraphsForOneSupply = new LinkedList<>();
			//get every 1st then 2nd etc... Subgraph of all Subgraphs
			for(int p = 0; p <= arrayOfBestGreedySolutions.length - 1; p++) {
				SolvedGraph solvOne = arrayOfBestGreedySolutions[p];
				if(solvOne == null) {
					//System.out.println("Only found " + p + " best solutions: please reduce Threshold");
					break;
				}
				subgraphsForOneSupply.add(solvOne.getSubgraph(n));   
				
		    }
			ListForEachSupply.add(subgraphsForOneSupply);
			
		}
		
		//reset Vertices now, because they get changed by creation of the subgraphs
		GreedyMPGSDSolver.resetGraphVertices(g);
		//now ListForEachSupply.get(0) should contain all subgraphs representing the Subgraphs containing SupplyVertex1 and so on...
		for(int x = 0; x <= ListForEachSupply.size() - 1; x++) {
			SubGraph fixedSet = findFixedSet(ListForEachSupply.get(x), g);
			fixedSets.add(fixedSet);
		}
		
		
		
		
		return fixedSets;
