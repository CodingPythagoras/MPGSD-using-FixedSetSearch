Contains all the code which was removed due to improvement or is just not needed anymore

//	public static LinkedList<LinkedList<Vertex>> GreedySolve(MPGSDGraph g) {
//		LinkedList<LinkedList<Vertex>> allSubgraphs = new LinkedList<>();
//		
//		
//		for(int i = 0; i <=  g.getListOfSupplyVertexes().size() - 1; i++) {
//			
//			SupplyVertex SupV = g.getHighestSupplyVertex();
//			LinkedList<Vertex> subGraph = new LinkedList<Vertex>();
//			allSubgraphs.add(subGraph);
//			subGraph.add(SupV);
//			Vertex currentV = SupV;
//			
//			while(true) {
//				//TODO When demandVertex not null
//				Vertex[] demandPair = getHighestListAdjVertex(subGraph);
//				DemandVertex selctedAdjDemV = (DemandVertex) demandPair[0];
//				if(selctedAdjDemV == null) {
//					break;
//				}
//				currentV = demandPair[1];
//				currentV.addAdjVertex(selctedAdjDemV);
//				selctedAdjDemV.setPredecessor(currentV);
//				subGraph.add(selctedAdjDemV);
//				SupV.useSupply(selctedAdjDemV.getDemand());
//				selctedAdjDemV.setDemandAsCovered();
//			}
//			
//		}
//		
//		return allSubgraphs;
//	}

public static Vertex[] getHighestListAdjVertex(SubGraph vListSubgraph) {
		//because first element in subgraph is always the supply Vertex
		
		int remainingSupply = vListSubgraph.getSubgraphsSupplyVertex().getRemainingSupply();
		//TODO null fix?
		DemandVertex bestFittingDemandVertex = null;
		Vertex predecessor = null;
		int maxDem = 0;
		LinkedList<Vertex> vList = vListSubgraph.getVertexList(); 
		
		for (int i = 0; i <= vList.size() - 1; i++ ) {
			Vertex k = vList.get(i);
			//getHighestFittingAdjVertex is swappable with function of choise
			DemandVertex currentAdjDemV = (DemandVertex) k.getHighestFittingAdjVertex(remainingSupply /*, vList*/);
			if(currentAdjDemV != null) {
				/*
				 * TODO currently only takes the one with the most demand of the given
				 */
				if(maxDem < currentAdjDemV.getDemand()) {
					maxDem = currentAdjDemV.getDemand();
					bestFittingDemandVertex = currentAdjDemV;
					predecessor = k;
				}
			}
			
			
		}
		return new Vertex[] {bestFittingDemandVertex, predecessor};
	}
	
	
	/*
	 * returns the highest fitting Vertex, that is not already in a subgraph (demand covered),
	 * highest fitting, means Vertex with the most Adj Vertexes, which demand can be fullfilled
	 */
	public Vertex getVertexWMostAdjV(int remainingSupply) {
		int currentMaxAdjV = 0;
		Vertex currentMaxAdjVertex = null;
		
		for (int i = 0; i <= AdjVertexList.size() - 1; i++) {
			Vertex k = AdjVertexList.get(i);
			
			if(!k.isSupplyVertex && ((DemandVertex) k).getDemandIsCovered() == false && remainingSupply >= ((DemandVertex) k).getDemand()) {
				if(k.AdjVertexList.size() > currentMaxAdjV) {
					currentMaxAdjV = k.AdjVertexList.size();
					currentMaxAdjVertex = k;
				}
			}
		}
		return currentMaxAdjVertex;
	}
	
	
	/*
	 * returns the highest fitting Vertex, that is not already in a subgraph (demand covered),
	 * highest fitting, means Vertex with the most supply, which can be fullfilled
	 */
	public Vertex getHighestFittingAdjVertex(int remainingSupply /*, LinkedList<Vertex> vList*/) {
		int currentMaxDemand = 0;
		Vertex currentMaxAdjDemandVertex = null;
		
		for (int i = 0; i <= AdjVertexList.size() - 1; i++) {
			Vertex k = AdjVertexList.get(i);
			
			
			if (k instanceof DemandVertex) {
				int currentDemand = ((DemandVertex) k).getDemand();
				if(currentMaxDemand < currentDemand && currentDemand <= remainingSupply && ((DemandVertex) k).getDemandIsCovered() == false /*&& !vList.contains(k)*/) {
					currentMaxDemand = currentDemand;
					currentMaxAdjDemandVertex = k;
				}
				
			}
		}
		return currentMaxAdjDemandVertex;	
	}
	
	
	
		/*
	 * returns the highest fitting Vertex, that is not already in a subgraph (demand covered),
	 * highest fitting, means Vertex with the best Ratio of 1 / (demand / adjacent Vertexes that are not covered)
	 * and that the demand can be fullfilled
	 */
	public Vertex getVertexUsingDemVertexRatio(int remainingSupply) {
		double currentBestRatio = 0;
		Vertex currentBestRatioVertex = null;
		
		for (int i = 0; i <= AdjVertexList.size() - 1; i++) {
			Vertex k = AdjVertexList.get(i);
			
			if(!k.isSupplyVertex && ((DemandVertex) k).getDemandIsCovered() == false && remainingSupply >= ((DemandVertex) k).getDemand()) {
				int numberOfAdjVDemNotCovered = 0;
				/*
				 * Determines how many Adj vertexes arent supplyed yet
				 */
				for(int j = 0; j <= k.AdjVertexList.size() - 1 ; j++) {
					Vertex kj = k.AdjVertexList.get(j);
					if(!kj.getIsSupplyVertex() && !((DemandVertex) kj).getDemandIsCovered()) {
						numberOfAdjVDemNotCovered += 1;
					}
				}
				int demToCov = ((DemandVertex) k).getDemand();
				double x = demToCov / (numberOfAdjVDemNotCovered + 1);
				double currentRatio = 1 / x;
				System.out.println(x);
				if(currentRatio > currentBestRatio) {
					currentBestRatio = currentRatio;
					currentBestRatioVertex = k;
				}
			}
		}
		return currentBestRatioVertex;
	}
	
	
		public Vertex getRandomAdjVertex(int remainingSupply) {
		
		Vertex ranAdjVer = null;
		LinkedList<Vertex> possibleAdjDemandVertexes = getListOfAdjNotCoveredFittingVertexes(remainingSupply);
		int sizeList = possibleAdjDemandVertexes.size();
		if(sizeList > 0) {
			Random randomNumber = new Random();
			int ranAdj = randomNumber.nextInt(sizeList);
			ranAdjVer = possibleAdjDemandVertexes.get(ranAdj);
		}
		return ranAdjVer;
	}
	
	
	/*
	 * returns the highest fitting Vertex using either
	 * getHighestFittingAdjVertex (Adj Vertex with highest demand)
	 * getVertexWMostAdjV (Vertex with most adj Vertexes)
	 * getVertexUsingDemVertexRatio (determines Vertex by combining both criteria)
	 */
	public Vertex getVertexUsingRandomTrait(int remainingSupply) {
		Vertex randomBestVertex = null;
		//Random number between 1 and 3
		Random randomNumber = new Random();
		int ranOneTwoThree = randomNumber.nextInt(3) + 1;
		switch (ranOneTwoThree) {
		case 1:
			randomBestVertex = getHighestFittingAdjVertex(remainingSupply);
			break;
		case 2:
			randomBestVertex = getVertexWMostAdjV(remainingSupply);
			break;
		case 3:
			randomBestVertex = getVertexUsingDemVertexRatio(remainingSupply);
			break;
		default:
			break;
		}
		
		return randomBestVertex;
	}
	
	
	private void createFirstMPGSDGraph() {
		SupplyVertex sup1 = new SupplyVertex(1, 10);
		SupplyVertex sup2 = new SupplyVertex(2, 5);
		SupplyVertex sup3 = new SupplyVertex(3, 7);
		SupplyVertex sup4 = new SupplyVertex(4, 8);
		listOfSupplyVertexes.add(sup1);
		listOfSupplyVertexes.add(sup2);
		listOfSupplyVertexes.add(sup3);
		listOfSupplyVertexes.add(sup4);
		
		DemandVertex dem1 = new DemandVertex(5, 3);
		DemandVertex dem2 = new DemandVertex(6, 4);
		DemandVertex dem3 = new DemandVertex(7, 2);
		DemandVertex dem4 = new DemandVertex(8, 1);
		
		DemandVertex dem5 = new DemandVertex(9, 5);
		
		DemandVertex dem6 = new DemandVertex(10, 4);
		DemandVertex dem7 = new DemandVertex(11, 3);
		DemandVertex dem8 = new DemandVertex(12, 2);
		DemandVertex dem9 = new DemandVertex(13, 1);
		
		DemandVertex dem10 = new DemandVertex(14, 3);
		DemandVertex dem11 = new DemandVertex(15, 1);
		DemandVertex dem12 = new DemandVertex(16, 2);
		DemandVertex dem13 = new DemandVertex(17, 7);
		listOfDemandVertexes.add(dem1);
		listOfDemandVertexes.add(dem2);
		listOfDemandVertexes.add(dem3);
		listOfDemandVertexes.add(dem4);
		listOfDemandVertexes.add(dem5);
		listOfDemandVertexes.add(dem6);
		listOfDemandVertexes.add(dem7);
		listOfDemandVertexes.add(dem8);
		listOfDemandVertexes.add(dem9);
		listOfDemandVertexes.add(dem10);
		listOfDemandVertexes.add(dem11);
		listOfDemandVertexes.add(dem12);
		listOfDemandVertexes.add(dem13);
		
		//Adjacency initialisation
		sup1.addAdjVertex(dem1);
		sup1.addAdjVertex(dem5);
		sup1.addAdjVertex(sup3);
		
		sup2.addAdjVertex(dem5);
		sup2.addAdjVertex(dem10);
		sup2.addAdjVertex(dem6);
		
		sup3.addAdjVertex(dem6);
		sup3.addAdjVertex(dem8);
		
		sup4.addAdjVertex(dem11);
		sup4.addAdjVertex(dem12);
		sup4.addAdjVertex(dem4);
		
		dem1.addAdjVertex(dem2);
		dem2.addAdjVertex(dem3);
		dem2.addAdjVertex(dem5);
		dem3.addAdjVertex(dem4);
		
		dem10.addAdjVertex(dem11);
		dem12.addAdjVertex(dem13);
		dem7.addAdjVertex(dem6);
		dem7.addAdjVertex(dem8);
		dem9.addAdjVertex(dem7);
		dem9.addAdjVertex(dem8);
		
		
	}